# PlantPal Scheduler-Service

The **Scheduler-Service** is a background microservice in the *PlantPal* ecosystem that handles automated reminder processing. It continuously polls for due reminders, resolves target phone numbers, and triggers notifications via AWS Lambda. The service runs as a cron-based scheduler, ensuring timely delivery of plant care reminders to users.

---

## Overview

| Key Feature | Description |
|--------------|-------------|
| **Role** | Background scheduler that processes due reminders and triggers notifications |
| **Pattern** | Implements **Scheduled Task** pattern with cron-based polling |
| **Technology** | Node.js, TypeScript, Express, node-cron |
| **Dependencies** | Reminder-Service (for due reminders), User-Service (for phone resolution), AWS Lambda (for notifications) |
| **Execution** | Continuous background process with configurable polling intervals |
| **Resilience** | Parallel processing with error isolation, continues processing even if individual reminders fail |

---

## Architecture and Communication Pattern

```
Scheduler-Service (Cron Job)
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚Üí Reminder-Service (HTTP GET) ‚Üí Fetch due reminders
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚Üí User-Service (HTTP GET) ‚Üí Resolve phone numbers
    ‚îÇ
    ‚îî‚îÄ‚îÄ‚Üí AWS Lambda (Invoke) ‚Üí Send SMS notifications
```

- **Scheduler-Service ‚Üî Reminder-Service** ‚Äî synchronous **HTTP orchestration** to fetch due reminders
- **Scheduler-Service ‚Üî User-Service** ‚Äî synchronous **HTTP orchestration** to resolve user phone numbers
- **Scheduler-Service ‚Üî AWS Lambda** ‚Äî **asynchronous invocation** to send SMS notifications

This architecture ensures:
- **Separation of Concerns:** Scheduler handles timing and orchestration, not business logic
- **Loose Coupling:** Services communicate via well-defined HTTP APIs
- **Scalability:** Can process multiple reminders in parallel
- **Fault Tolerance:** Individual reminder failures don't stop the entire process

### Processing Flow

1. **Cron Job Trigger:**
   - Cron job fires at configured interval (default: every 30 seconds)
   - Calls `pollAndProcessReminders()` function

2. **Fetch Due Reminders:**
   - Sends HTTP GET request to Reminder-Service
   - Queries for reminders due within the configured time window
   - Receives list of due reminders

3. **Process Each Reminder (Parallel):**
   - For each reminder:
     - Resolve target phone number (user phone or proxy phone)
     - Format phone number to E.164 format
     - Invoke AWS Lambda function to send SMS notification
   - Process all reminders concurrently using `Promise.allSettled`

4. **Error Handling:**
   - Individual reminder failures are logged but don't stop processing
   - Summary of successes and failures is logged after each poll cycle

---

## Project Structure

```
scheduler-service/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ server.ts              # Main server (Express + cron setup)
‚îÇ   ‚îú‚îÄ‚îÄ scheduler.ts            # Core scheduler logic (polling and processing)
‚îÇ   ‚îú‚îÄ‚îÄ activities.ts           # External service calls (reminders, users, Lambda)
‚îÇ   ‚îî‚îÄ‚îÄ env.ts                  # Environment configuration and validation
‚îú‚îÄ‚îÄ dist/                       # Compiled JavaScript (generated by build)
‚îú‚îÄ‚îÄ docker-compose/             # Temporal workflow engine configurations (legacy)
‚îú‚îÄ‚îÄ Dockerfile                  # Multi-stage Docker build configuration
‚îú‚îÄ‚îÄ tsconfig.json               # TypeScript compiler configuration
‚îú‚îÄ‚îÄ package.json                # Dependencies and scripts
‚îú‚îÄ‚îÄ RUN_AND_TEST.md            # Detailed run and test guide
‚îî‚îÄ‚îÄ README.md                   # This file
```

---

## Technical Implementation

### Core Libraries
| Library | Purpose | Version |
|----------|----------|---------|
| **Express** | Web framework for health check endpoint | ^4.21.2 |
| **node-cron** | Cron job scheduler for periodic tasks | ^3.0.3 |
| **Axios** | HTTP client for inter-service communication | ^1.7.9 |
| **AWS SDK Lambda** | AWS Lambda client for notification invocation | ^3.929.0 |
| **TypeScript** | Type-safe JavaScript development | ^5.9.3 |
| **Zod** | Runtime type validation | ^3.23.8 |
| **dotenv** | Environment variable management | ^16.4.5 |

### Environment Variables

The service requires the following environment variables:

| Variable | Description | Required | Default |
|----------|-------------|----------|---------|
| `PORT` | Port number for health check endpoint | No | `4000` |
| `REMINDER_SERVICE_BASEURL` | Base URL of the reminder service | Yes | - |
| `USER_SERVICE_BASEURL` | Base URL of the user service | Yes | - |
| `POLL_INTERVAL_MS` | Polling interval in milliseconds | No | `30000` (30 seconds) |
| `DUE_WINDOW_SEC` | Time window in seconds to look ahead for due reminders | No | `60` (1 minute) |
| `AUTH_BEARER` | Bearer token for authenticating with other services | No | `"DEV"` |
| `AWS_REGION` | AWS region for Lambda invocation | No | `"ap-southeast-1"` |
| `NOTIF_FN` | AWS Lambda function name for notifications | No | `"sendReminder"` |
| `TZ` | Timezone for date/time operations | No | `"Asia/Singapore"` |

**Example `.env` file:**
```env
# External Services
REMINDER_SERVICE_BASEURL=http://reminder-service:3000
USER_SERVICE_BASEURL=http://user-service:3001

# Polling Configuration
POLL_INTERVAL_MS=30000
DUE_WINDOW_SEC=60

# Security
AUTH_BEARER=your-bearer-token-here

# AWS Configuration
AWS_REGION=ap-southeast-1
NOTIF_FN=sendReminder

# Timezone
TZ=Asia/Singapore

# Server
PORT=4000
```

### Cron Job Configuration

The service automatically generates a cron expression based on `POLL_INTERVAL_MS`:

- **Intervals < 60 seconds:** Uses 6-field cron with seconds
  - Format: `*/X * * * * *` (seconds minutes hours day month weekday)
  - Example: `*/30 * * * * *` (every 30 seconds)
  
- **Intervals >= 60 seconds:** Uses 5-field cron (standard)
  - Format: `*/X * * * *` (minutes hours day month weekday)
  - Example: `*/5 * * * *` (every 5 minutes)

**Minimum Interval:** 5 seconds (enforced for performance reasons)

**Cron Expression Examples:**
- `POLL_INTERVAL_MS=10000` ‚Üí `*/10 * * * * *` (every 10 seconds)
- `POLL_INTERVAL_MS=30000` ‚Üí `*/30 * * * * *` (every 30 seconds)
- `POLL_INTERVAL_MS=60000` ‚Üí `*/1 * * * *` (every 1 minute)
- `POLL_INTERVAL_MS=300000` ‚Üí `*/5 * * * *` (every 5 minutes)

### Due Window Configuration

The `DUE_WINDOW_SEC` parameter defines how far ahead the service looks for due reminders:

- **Purpose:** Prevents missing reminders due to timing issues
- **Default:** 60 seconds (1 minute)
- **Example:** If `DUE_WINDOW_SEC=60`, the service fetches reminders due within the next 60 seconds
- **Recommendation:** Set to at least 2x the polling interval to ensure no reminders are missed

---

## API Endpoints

### Health Check

#### `GET /`
Simple health check endpoint to verify the service is running.

**Response (200 OK):**
```json
{
  "status": "ok"
}
```

**Use Cases:**
- Container orchestration health checks (ECS, Kubernetes)
- Load balancer health monitoring
- Service discovery registration

---

## Processing Logic

### Reminder Processing

The service processes reminders in the following steps:

1. **Fetch Due Reminders:**
   ```typescript
   GET /reminder/v1/reminders/due?windowSec={DUE_WINDOW_SEC}
   Headers: Authorization: Bearer {AUTH_BEARER}
   ```

2. **For Each Reminder:**
   - **Resolve Phone Number:**
     - If `is_proxy === true` and `proxy` is set: Use proxy phone number
     - Otherwise: Fetch user phone from User-Service
       ```typescript
       GET /users/{user_id}
       Headers: Authorization: Bearer {AUTH_BEARER}
       ```

   - **Format Phone Number:**
     - Ensures E.164 format (e.g., `+6512345678`)
     - Adds `+65` prefix if missing (Singapore default)

   - **Send Notification:**
     - Invokes AWS Lambda function with payload:
       ```json
       {
         "messageId": "rmdr_{timestamp}",
         "channel": "sms",
         "to": "+6512345678",
         "plantName": "Reminder Name",
         "action": "Reminder Name",
         "dueAt": "2024-01-01T12:00:00.000Z",
         "tz": "Asia/Singapore",
         "notes": "Reminder notes or 'No notes provided'"
       }
       ```

### Parallel Processing

Reminders are processed in parallel using `Promise.allSettled`:

- **Benefits:**
  - Faster processing of multiple reminders
  - Isolation of failures (one failure doesn't affect others)
  - All reminders are attempted, even if some fail

- **Error Handling:**
  - Individual failures are logged but don't stop processing
  - Summary of successes and failures is logged after each poll

### Reminder Data Structure

```typescript
type ReminderRow = {
  id: string;              // Reminder UUID
  user_id: string;         // User UUID
  name: string;            // Reminder name (e.g., "Water plant")
  notes: string | null;    // Additional notes
  due_at: string;          // ISO8601 timestamp
  is_proxy: boolean;       // Whether to use proxy phone
  proxy: string | null;    // Proxy phone number (if is_proxy is true)
  sent_at?: string | null; // Timestamp when sent (optional)
};
```

---

## Security Practices

| Practice | Implementation | Details |
|-----------|----------------|---------|
| **Bearer Token Authentication** | `Authorization: Bearer {token}` header | Required for all inter-service calls |
| **Environment Variables** | Secrets stored in environment, not code | Prevents credential exposure |
| **AWS IAM** | Lambda invocation requires proper IAM permissions | Ensures secure Lambda access |
| **Error Logging** | Detailed logging without exposing sensitive data | Phone numbers logged but not sensitive data exposed |
| **Input Validation** | TypeScript types and runtime validation | Prevents malformed data processing |

### AWS Lambda Permissions

The service requires the following AWS IAM permissions:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "lambda:InvokeFunction"
      ],
      "Resource": "arn:aws:lambda:{region}:{account}:function:{function-name}"
    }
  ]
}
```

---

## Error Handling and Resilience

### Error Handling Strategy

1. **Network Errors:**
   - HTTP request failures are caught and logged
   - Service continues running and retries on next poll cycle
   - No retry logic within a single poll (relies on next cron trigger)

2. **Lambda Invocation Errors:**
   - Lambda invocation failures are logged per reminder
   - Individual reminder failures don't stop processing of other reminders
   - Errors are logged with context (reminder ID, error message)

3. **Service Unavailability:**
   - If Reminder-Service is unavailable, poll returns empty array
   - If User-Service is unavailable, phone resolution fails for affected reminders
   - Service continues running and retries on next poll

### Logging

The service provides detailed console logging:

- **Startup:** Cron expression, polling interval, due window
- **Polling:** Number of reminders found, processing status
- **Processing:** Individual reminder processing status
- **Lambda:** Invocation details and results
- **Errors:** Detailed error messages with context

**Log Format Examples:**
```
üöÄ Starting scheduler-service...
‚è∞ Setting up cron job: */30 * * * * * (every 30s)
üïí Polling for due reminders...
‚úÖ [listDueReminders] Received 3 reminder(s)
üìã Processing reminder: abc-123 - Water plant
üì§ [sendNotification] Invoking Lambda: sendReminder
‚úÖ Successfully processed reminder: abc-123
üìä Reminder processing complete: 3 succeeded, 0 failed
```

---

## Development

### Prerequisites

- **Node.js 20+** (Alpine Linux compatible for Docker)
- **npm** or **yarn** package manager
- **TypeScript** knowledge (service is written in TypeScript)
- **AWS Account** with Lambda function configured
- **Docker** (optional, for containerized development)

### Local Development Setup

1. **Install Dependencies:**
   ```bash
   npm install
   ```

2. **Configure Environment:**
   Create a `.env` file with required environment variables (see [Environment Variables](#environment-variables) section).

3. **Development Mode (with auto-reload):**
   ```bash
   npm run dev
   ```
   Uses `tsx` for direct TypeScript execution with hot reload.

4. **Production Build:**
   ```bash
   npm run build
   npm start
   ```
   Compiles TypeScript to JavaScript in `dist/` folder.

### Development Scripts

| Script | Command | Description |
|--------|---------|-------------|
| `dev` | `tsx src/server.ts` | Start in development mode with auto-reload |
| `build` | `tsc` | Compile TypeScript to JavaScript |
| `start` | `node dist/server.js` | Start compiled JavaScript (production) |

### TypeScript Configuration

The service uses strict TypeScript configuration:
- **Target:** ES2022
- **Module:** ESNext
- **Strict Mode:** Enabled
- **Source Maps:** Enabled for debugging
- **Module Resolution:** Node.js

See `tsconfig.json` for full configuration.

---

## Testing

### Manual Testing

1. **Health Check:**
   ```bash
   curl http://localhost:4000/
   ```
   Expected: `{"status":"ok"}`

2. **Verify Cron Job:**
   - Check service logs for periodic polling messages
   - Should see `üïí Polling for due reminders...` at configured intervals

3. **End-to-End Test:**
   - Ensure Reminder-Service has reminders due within the next `DUE_WINDOW_SEC` seconds
   - Monitor service logs for processing messages
   - Verify Lambda function is invoked (check AWS CloudWatch logs)

### Testing Reminder Service Integration

```bash
curl -H "Authorization: Bearer DEV" \
  "http://localhost:3000/reminder/v1/reminders/due?windowSec=60"
```

### Testing User Service Integration

```bash
curl -H "Authorization: Bearer DEV" \
  "http://localhost:3001/users/{user-id}"
```

### Testing Lambda Invocation

Check AWS CloudWatch logs for your Lambda function to verify:
- Function is being invoked
- Payload format is correct
- SMS is being sent successfully

---

## DevOps and CI/CD Integration

### Docker Configuration

The service uses a multi-stage Docker build:

- **Stage 1 (Build):** Installs dependencies and compiles TypeScript
- **Stage 2 (Runtime):** Minimal Alpine-based image with only runtime files

**Dockerfile Features:**
- Node.js 20 Alpine base image
- Production dependencies only
- Compiled JavaScript in `dist/` folder
- Exposes port 4000

### Container Deployment

```bash
# Build image
docker build -t scheduler-service .

# Run container
docker run -p 4000:4000 --env-file .env scheduler-service
```

### Production Considerations

1. **Process Management:**
   - Use process managers (PM2, systemd) or container orchestration (ECS, Kubernetes)
   - Ensure service restarts automatically on failure

2. **Monitoring:**
   - Set up health check monitoring (endpoint: `GET /`)
   - Monitor cron job execution frequency
   - Track reminder processing success/failure rates
   - Set up alerts for service downtime

3. **Logging:**
   - Integrate with centralized logging (CloudWatch, ELK stack)
   - Log aggregation for distributed troubleshooting
   - Structured logging for better analysis

4. **Resource Limits:**
   - Set appropriate CPU/memory limits
   - Monitor resource usage during peak processing times
   - Consider horizontal scaling if processing large volumes

5. **AWS Configuration:**
   - Ensure IAM role/user has Lambda invocation permissions
   - Configure VPC if Lambda is in a VPC
   - Set up CloudWatch alarms for Lambda errors

---

## Troubleshooting

### Common Issues

1. **Service not starting:**
   - Check that all required environment variables are set
   - Verify Node.js version is 20+: `node --version`
   - Check for TypeScript compilation errors: `npm run build`
   - Review startup logs for specific error messages

2. **Cron job not running:**
   - Verify `POLL_INTERVAL_MS` is set correctly (minimum 5000ms)
   - Check service logs for cron setup messages
   - Ensure the service process is still running
   - Verify `node-cron` is working (check logs for cron triggers)

3. **Reminders not being fetched:**
   - Verify `REMINDER_SERVICE_BASEURL` is correct and accessible
   - Check Reminder-Service is running: `curl http://reminder-service:3000/health`
   - Test the endpoint manually with correct `AUTH_BEARER` token
   - Check service logs for HTTP errors (status codes, error messages)
   - Verify network connectivity between services

4. **Phone numbers not resolving:**
   - Verify `USER_SERVICE_BASEURL` is correct and accessible
   - Check User-Service is running
   - Test the endpoint manually with a valid user ID
   - Check service logs for errors during phone resolution
   - Verify user exists and has a phone number

5. **Lambda not being invoked:**
   - Verify AWS credentials are configured
   - Check `AWS_REGION` and `NOTIF_FN` environment variables
   - Review AWS CloudWatch logs for Lambda errors
   - Ensure Lambda function exists and is accessible
   - Verify IAM role/user has `lambda:InvokeFunction` permission
   - Check Lambda function name matches `NOTIF_FN` exactly

6. **Service crashes or stops:**
   - Check for unhandled promise rejections in logs
   - Verify all external services are reachable
   - Check for memory issues (cron jobs run in the same process)
   - Review error logs for specific failure points
   - Ensure process manager is configured for auto-restart

7. **Reminders being missed:**
   - Increase `DUE_WINDOW_SEC` to look further ahead
   - Decrease `POLL_INTERVAL_MS` to poll more frequently
   - Check Reminder-Service is returning correct due reminders
   - Verify timezone configuration (`TZ` environment variable)

### Debugging Tips

1. **Enable verbose logging:**
   - Service already includes detailed logging
   - Check console output for processing details

2. **Test individual components:**
   - Test Reminder-Service endpoint directly
   - Test User-Service endpoint directly
   - Test Lambda function invocation manually

3. **Monitor AWS CloudWatch:**
   - Check Lambda function logs
   - Monitor Lambda invocation metrics
   - Review error rates and patterns

4. **Check service dependencies:**
   - Ensure all dependent services are running
   - Verify network connectivity
   - Test authentication tokens

---

## Architecture Decisions

### Why Cron Instead of Event-Driven?

- **Simplicity:** Cron-based polling is straightforward and reliable
- **No Message Queue Required:** Doesn't need additional infrastructure (SQS, RabbitMQ)
- **Predictable:** Easy to understand and debug
- **Sufficient for Use Case:** Polling interval is configurable and meets requirements

### Why Parallel Processing?

- **Performance:** Multiple reminders can be processed simultaneously
- **Fault Isolation:** One failure doesn't block others
- **Scalability:** Can handle bursts of due reminders efficiently

### Why AWS Lambda for Notifications?

- **Serverless:** No need to manage notification infrastructure
- **Scalability:** Lambda automatically scales with load
- **Cost-Effective:** Pay only for invocations
- **Integration:** Easy integration with Twilio, SNS, etc.

### Why TypeScript?

- **Type Safety:** Catches errors at compile time
- **Better IDE Support:** Autocomplete and refactoring
- **Maintainability:** Easier to understand and modify code
- **Modern JavaScript:** Uses latest ES features

---

## Related Services

- **Reminder-Service:** Provides due reminders via HTTP API
- **User-Service:** Provides user phone numbers for notification delivery
- **Notification-Service (Lambda):** Sends SMS notifications via Twilio

---

## Additional Resources

- **Detailed Run and Test Guide:** See `RUN_AND_TEST.md` for comprehensive testing instructions
- **TypeScript Documentation:** https://www.typescriptlang.org/docs/
- **node-cron Documentation:** https://github.com/node-cron/node-cron
- **AWS Lambda SDK:** https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-lambda/

---

## Future Enhancements

Potential improvements for the service:

1. **Retry Logic:** Add retry mechanism for failed reminder processing
2. **Metrics:** Add Prometheus metrics for monitoring
3. **Dead Letter Queue:** Store failed reminders for manual review
4. **Rate Limiting:** Add rate limiting for Lambda invocations
5. **Batch Processing:** Process reminders in batches for efficiency
6. **Health Check Enhancement:** Add dependency health checks
7. **Configuration API:** Allow dynamic configuration updates
8. **Event-Driven Option:** Add support for event-driven processing (SQS, etc.)
